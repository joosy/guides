---
layout: guide
title: "Search engines indexing"
version: 1.1
language: en
---

{% assign gist_id = 2127685 %}

Javascript frameworks are widely criticized for the potential problems with search engines indexing. While this is not the case for private parts of your site, sometimes you might want use Joosy for the publicly visible part as well. Fortunately, to solve this problem Google introduced [AJAX Crawling API](https://developers.google.com/webmasters/ajax-crawling/). Nowadays it is supported not only by Google but also by Bing (and therefore Yahoo) and local market players.

It works by replacing the hashbang (#!) in your url.

![](https://developers.google.com/webmasters/ajax-crawling/docs/images/crawlerserver2.png)

This guide won't cover details of this process since it's mostly hidden from the end user.

To automate this process we created [Rack](http://rack.github.com/)-based solution called [Hashbang](https://github.com/roundlake/hashbang). This is how it works:

<div style="text-align: center; width: 100%">
  <img src="http://f.cl.ly/items/2P0S2a0K0V2r3Y2Q1O33/hashbang.png" />
</div>

You setup your http balancer to proxy everything containing `_escaped_fragment_` at its url to a separate Rack-based application. Hashbang gets it, loads your main application using bundled webkit, takes the snapshot generated by your JS App and gives it back to search engine. And your Javascript gets evaluated and indexed.

Internally Hashbang consists of two parts. The gem with Rack layer itself and the [Sunscraper](https://github.com/roundlake/sunscraper) gem that does the dirty job. Sunscraper is the independent gem that bundles QT Webkit and is able to grab  your RICH applications. It loads the application and waits for the special JS function to be called. As soon as it happens, it takes current window HTML and returns it.

To make debugging comfortable, Hashbang has a special workflow for the Rails development mode. It uses middleware stack to capture `_escaped_fragment_` requests without HTTP balancer. On a local machine you can just check your urls with a single limitation:  it won't work with a typical single-threaded webrick server run. If you want to test Hashbang, run your server with `rake hashbang:rails`. It will start a double-threaded Unicorn.

Let's walk through step by step proccess.

## Dependencies

Hashbang depends on Qt to use its WebKit bundle. To install it use:

* Mac ([Homebrew](http://mxcl.github.com/homebrew/)): `brew install qt`
* Linux: `apt-get install qt4-dev-tools --no-install-recommends`

Add gem to your Gemfile: `gem hashbang` and run `bundle install`.

## Application setup

Before we can use hashbang at development mode, we need to pregenerate internal application. Use `rails g hashbang` to create it. It will create `hashbang` subdirectory inside your application root with the following content:

<div class="black_wheel">
  <pre>.
├── config.rb
├── config.ru
├── lib
│   └── wrapper.rb
├── public
├── tmp
└── unicorn.rb</pre>
</div>

Inside the config.rb file hashbang keeps its settings. It has just two directives:

* **url**: allows you to specify regular expression that will keep hashbang from loading anything else. By default hashbang will work with any url and that's totally wrong. So ensure to add correct domain check here.
* **timeout**: this is the maximum time it will wait for the page to load and finish JS preparations.

Now that hashbang is ready, we need to add proper JS call to notify crawler that page is ready. To do this you have to call `Sunscraper.finish()`. Remember that for the direct queries, you won't get a Sunscraper object defined. So if you are using CoffeeScript, you should call `Sunscraper?.finish()` to not break your default bootstrap process.

Joosy has a special page event that could be used:

{% assign gist_file = 'page.coffee' %}
{% include gist.html %}

Run your application with `rake hashbang:rails` and check any local url replaced by API rules (change `#!` to `?_escaped_fragment=`). It should dump page's HTML.

## Server setup (nginx + passenger)

Here is the typical Nginx setup that is worth a thousand words:

{% assign gist_file = 'nginx.conf' %}
{% include gist.html %}

This setup desribes both: how you define additional hashbang application and how you proxy required requests to it.

Note that we used `limit_conn` directive that is not compiled into nginx by default. Still you are very encouraged to use it to protect your server from additional load (without this limit, hashbang is an easy spot for DDOS).

<div class="warning">
  <p style="padding-bottom: 20px">
    We use Hashbang at several projects having a lot of active users. And it works. There is however a strange bug that we can not defeat yet. Under load it may accidentally die because of WebKit. It's instance just hangs and doesn't respond. It happens randomly (once per ~3 days under heavy load in our case). 
  </p>
  <p>
    We miss years of experience in Qt so if you are Qt expert, please contribute. <a href="https://github.com/roundlake/sunscraper">Sunscraper</a> is on github, just get in touch, we'll provide additional info.
  </p>
</div>